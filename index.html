<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat App</title>
  <style>
    /* Tailwind-like CSS with variables */
    :root {
      --bg-primary: #2C2F33; /* Dark gray */
      --accent: #6A1B9A; /* Purple */
      --text: #FFFFFF;
    }

    [data-theme="light"] {
      --bg-primary: #FFFFFF;
      --accent: #AB47BC; /* Lighter purple */
      --text: #000000;
    }

    body {
      background-color: var(--bg-primary);
      color: var(--text);
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
    }

    .flex {
      display: flex;
    }

    .flex-col {
      flex-direction: column;
    }

    .h-screen {
      height: 100vh;
    }

    .h-full {
      height: 100%;
    }

    .w-64 {
      width: 16rem;
    }

    .p-4 {
      padding: 1rem;
    }

    .border-r {
      border-right: 1px solid #ccc;
    }

    .flex-1 {
      flex: 1;
    }

    .overflow-y-auto {
      overflow-y: auto;
    }

    .cursor-pointer {
      cursor: pointer;
    }

    button {
      background-color: var(--accent);
      color: var(--text);
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      margin-top: 0.5rem;
    }

    input {
      background-color: var(--bg-primary);
      color: var(--text);
      border: 1px solid var(--accent);
      padding: 0.5rem;
      width: 100%;
      box-sizing: border-box;
    }

    ul {
      list-style: none;
      padding: 0;
    }

    li {
      margin-bottom: 0.5rem;
    }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <script src="https://unpkg.com/socket.io-client/dist/socket.io.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const socket = io('http://localhost:5000', {
      auth: { token: localStorage.getItem('token') }
    });

    const App = () => {
      const [theme, setTheme] = useState(localStorage.getItem('theme') || 'dark');
      const [groups, setGroups] = useState([]);
      const [selectedChannel, setSelectedChannel] = useState(null);
      const [messages, setMessages] = useState([]);
      const [input, setInput] = useState('');
      const [peers, setPeers] = useState({});
      const localAudioRef = useRef(null);
      const remoteAudioRefs = useRef({});

      useEffect(() => {
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
      }, [theme]);

      useEffect(() => {
        axios.get('http://localhost:5000/api/groups').then(res => setGroups(res.data));
      }, []);

      useEffect(() => {
        if (selectedChannel && selectedChannel.type === 'text') {
          axios.get(`http://localhost:5000/api/channels/${selectedChannel._id}/messages`).then(res => setMessages(res.data));
          socket.emit('joinChannel', selectedChannel._id);
          socket.on('receiveMessage', msg => setMessages(prev => [...prev, msg]));
        } else if (selectedChannel && selectedChannel.type === 'voice') {
          navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
              localAudioRef.current = new Audio();
              localAudioRef.current.srcObject = stream;
              localAudioRef.current.muted = true;
              socket.emit('joinVoiceChannel', selectedChannel._id);

              socket.on('peerJoined', ({ peerId }) => {
                createPeerConnection(peerId, stream, true);
              });

              socket.on('offer', async ({ offer, fromPeerId }) => {
                const pc = createPeerConnection(fromPeerId, stream, false);
                await pc.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                socket.emit('answer', { answer: pc.localDescription, toPeerId: fromPeerId });
              });

              socket.on('answer', ({ answer, fromPeerId }) => {
                const pc = peers[fromPeerId];
                if (pc) pc.setRemoteDescription(new RTCSessionDescription(answer));
              });

              socket.on('iceCandidate', ({ candidate, fromPeerId }) => {
                const pc = peers[fromPeerId];
                if (pc) pc.addIceCandidate(new RTCIceCandidate(candidate));
              });

              socket.on('peerLeft', ({ peerId }) => {
                const pc = peers[peerId];
                if (pc) pc.close();
                setPeers(prev => { const newPeers = { ...prev }; delete newPeers[peerId]; return newPeers; });
                if (remoteAudioRefs.current[peerId]) {
                  remoteAudioRefs.current[peerId].pause();
                  delete remoteAudioRefs.current[peerId];
                }
              });
            })
            .catch(err => console.error('Media error:', err));
        }

        return () => {
          if (selectedChannel) {
            if (selectedChannel.type === 'voice') socket.emit('leaveVoiceChannel', selectedChannel._id);
            socket.off('receiveMessage');
            socket.off('peerJoined');
            socket.off('offer');
            socket.off('answer');
            socket.off('iceCandidate');
            socket.off('peerLeft');
          }
        };
      }, [selectedChannel]);

      const createPeerConnection = (peerId, stream, isCaller) => {
        const pc = new RTCPeerConnection({
          iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });

        stream.getTracks().forEach(track => pc.addTrack(track, stream));

        pc.ontrack = (event) => {
          if (!remoteAudioRefs.current[peerId]) {
            const audio = new Audio();
            audio.srcObject = event.streams[0];
            audio.autoplay = true;
            remoteAudioRefs.current[peerId] = audio;
          }
        };

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('iceCandidate', { candidate: event.candidate, toPeerId: peerId });
          }
        };

        setPeers(prev => ({ ...prev, [peerId]: pc }));

        if (isCaller) {
          pc.createOffer().then(offer => {
            pc.setLocalDescription(offer);
            socket.emit('offer', { offer, toPeerId: peerId, channelId: selectedChannel._id });
          });
        }

        return pc;
      };

      const sendMessage = () => {
        if (input && selectedChannel.type === 'text') {
          socket.emit('sendMessage', { channelId: selectedChannel._id, content: input });
          setInput('');
        }
      };

      return (
        <div className="flex h-screen">
          <div className="w-64 bg-var(--bg-primary) p-4">
            <h2>Groups</h2>
            <ul>
              {groups.map(group => (
                <li key={group._id}>
                  {group.name}
                  <ul>
                    {group.channels?.map(channel => (
                      <li key={channel._id} onClick={() => setSelectedChannel(channel)} className="cursor-pointer">
                        {channel.name} ({channel.type})
                      </li>
                    ))}
                  </ul>
                </li>
              ))}
            </ul>
            <button onClick={() => setTheme(theme === 'dark' ? 'light' : 'dark')}>Toggle Theme</button>
          </div>
          <div className="flex-1 p-4">
            {selectedChannel ? (
              selectedChannel.type === 'text' ? (
                <div className="flex flex-col h-full">
                  <div className="flex-1 overflow-y-auto">
                    {messages.map((msg, idx) => <p key={idx}>{msg.content}</p>)}
                  </div>
                  <input value={input} onChange={e => setInput(e.target.value)} />
                  <button onClick={sendMessage}>Send</button>
                </div>
              ) : (
                <div>
                  <h2>Voice Channel: {selectedChannel.name}</h2>
                  <p>Connected peers: {Object.keys(peers).length}</p>
                </div>
              )
            ) : (
              <p>Select a channel</p>
            )}
          </div>
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
